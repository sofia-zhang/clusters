# -*- coding: utf-8 -*-
"""Recommender Systems Lab: Crash Course AI #16

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-v9cw18wTDjaCUlECKHsQnHeisLKyG8U

Recommender Systems are a class of AI systems that predict and recommend new items (e.g. YouTube videos, Netflix shows, Amazon products).

In this lab, we'll use recommender systems to try to find a good movie for our next movie night!

Here's what we need to do:
* Step 1: Get a dataset of movie ratings, and make sure we understand how the dataset is structured.
* Step 2: Try to get just a non-personalized set of recommendations for John-Green-bot and me, to see if we can find a movie to watch that way.
* Step 3: Get personalized ratings for John-Green-bot and me, and import them into the system in the correct format.
* Step 4: Train a User-User collaborative filtering model to provide personalized recommendations based on John-Green-bot's and my prior ratings.
* Step 5: Combine ratings to generate a single ranked recommendation list for our movie night together!

Just like in our other labs, we're not going to reinvent the wheel from scratch. We'll use an existing dataset published by MovieLens, which contains about 100,000 user ratings for about 10,000 different movies. You can read more about this dataset here: http://files.grouplens.org/datasets/movielens/ml-latest-small-README.html

We'll also use the LensKit API to implement our recommender systems algorithms.

***STEP 1***

**Step 1.1**
"""

import lenskit.datasets as ds
import pandas as pd
import csv
from lenskit.algorithms import Recommender
from lenskit.algorithms.user_knn import UserUser

data = ds.MovieLens('data/')


def getGeneralRecs():
#gen recs
  minimum_to_include = 20 #<-- You can try changing this minimum to include movies rated by fewer or more people

  average_ratings = (data.ratings).groupby(['item']).mean()
  rating_counts = (data.ratings).groupby(['item']).count()
  average_ratings = average_ratings.loc[rating_counts['rating'] > minimum_to_include]
  sorted_avg_ratings = average_ratings.sort_values(by="rating", ascending=False)
  joined_data = sorted_avg_ratings.join(data.movies['genres'], on='item')
  joined_data = joined_data.join(data.movies['title'], on='item')
  joined_data = joined_data[joined_data.columns[3:]]

  # print("RECOMMENDED FOR ANYBODY:")
  print(joined_data.head(10))
  return joined_data.head(10)

#specific recs

def getRecs(type):
  rating_dict = {}

  #configures csv file
  with open("rated.csv", newline='') as csvfile:
    ratings_reader = csv.DictReader(csvfile)
    for row in ratings_reader:

      if ((row['ratings'] != "") and (float(row['ratings'
      ]) > 0) and (float(row['ratings']) < 6)):
        # print(row)
        rating_dict.update({int(row['item']): float(row['ratings'])})

  #configure user user
  num_recs = 10

  min = 3
  max = 15

  if type == "small":
    min = 1
    max = 5
  elif type == "large":
    min = 10
    max = 30

  user_user = UserUser(max, min_nbrs=min) #These two numbers set the minimum (3) and maximum (15) number of neighbors to consider. These are considered "reasonable defaults," but you can experiment with others too
  algo = Recommender.adapt(user_user)
  algo.fit(data.ratings)

  print("Set up a User-User algorithm!")

  recs = algo.recommend(-1, num_recs, ratings=pd.Series(rating_dict))  #Here, -1 tells it that it's not an existing user in the set, that we're giving new ratings, while 10 is how many recommendations it should generate
  # print(recs)
  joined_data = recs.join(data.movies['genres'], on='item')      
  joined_data = joined_data.join(data.movies['title'], on='item')
  joined_data = joined_data[joined_data.columns[2:]]
  # print("RECOMMENDED")
  # print(joined_data.empty)


  return joined_data

# getRecs()